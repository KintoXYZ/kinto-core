// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "forge-std/Test.sol";
import "forge-std/console.sol";

import "@aa/interfaces/IEntryPoint.sol";
import {EntryPoint} from "@aa/core/EntryPoint.sol";

import "@kinto-core/wallet/KintoWallet.sol";
import "@kinto-core/wallet/KintoWalletFactory.sol";
import {SponsorPaymaster} from "@kinto-core/paymasters/SponsorPaymaster.sol";
import "@kinto-core/KintoID.sol";
import "@kinto-core/sample/Counter.sol";

import "@kinto-core-test/SharedSetup.t.sol";

contract SponsorPaymasterExploitTest is SharedSetup {
    using SignatureChecker for address;

    function testExploit() public {
        UserOperation[] memory userOps = new UserOperation[](1);
        userOps[0] = _createUserOperation(
            address(_kintoWallet),
            address(counter),
            _kintoWallet.getNonce(),
            privateKeys,
            abi.encodeWithSignature("increment()"),
            address(_paymaster)
        );
        userOps[0].callGasLimit = 40000; // generate from call simulation
        userOps[0].verificationGasLimit = 150000; // verification gas. will add create2 cost (3200+200*length) if initCode exists
        userOps[0].preVerificationGas = 99e18; // should also cover calldata cost.
        userOps[0].maxFeePerGas = 1; // grab from current gas
        userOps[0].maxPriorityFeePerGas = 1e9; // grab from current gas
        userOps[0].signature = _signUserOp(
            userOps[0], KintoWallet(payable(address(_kintoWallet))).entryPoint(), block.chainid, privateKeys
        );

        uint256 balanceBefore = _owner.balance;

        vm.expectRevert();
        _entryPoint.handleOps(userOps, payable(_owner));

        uint256 balanceAfter = _owner.balance;
        uint256 dust = 100_000;
        assertGt(balanceBefore, balanceAfter - dust, "Hacker's profit is too HIGH");
    }
}
