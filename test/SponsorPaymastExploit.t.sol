// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "forge-std/console.sol";

import "@aa/interfaces/IEntryPoint.sol";
import "@aa/core/EntryPoint.sol";

import "../src/wallet/KintoWallet.sol";
import "../src/wallet/KintoWalletFactory.sol";
import "../src/paymasters/SponsorPaymaster.sol";
import "../src/KintoID.sol";
import "../src/sample/Counter.sol";

import "./SharedSetup.t.sol";

// contract MyOpCreator is UserOp, KYCSignature {
//     function _createOp(
//         uint256 _chainID,
//         address _account,
//         uint256 nonce,
//         uint256[] calldata _privateKeyOwners,
//         address _target,
//         uint256 value,
//         bytes calldata _bytesOp,
//         address _paymaster
//     ) public view returns (UserOperation memory op) {
//         op = UserOperation({
//             sender: _account,
//             nonce: nonce,
//             initCode: bytes(""),
//             callData: abi.encodeCall(KintoWallet.execute, (_target, value, _bytesOp)),
//             callGasLimit: 40000, // generate from call simulation
//             verificationGasLimit: 150000, // verification gas. will add create2 cost (3200+200*length) if initCode exists
//             preVerificationGas: 99e18, // should also cover calldata cost.
//             maxFeePerGas: 1, // grab from current gas
//             maxPriorityFeePerGas: 1e9, // grab from current gas
//             paymasterAndData: abi.encodePacked(_paymaster),
//             signature: bytes("")
//         });
//         op.signature = _signUserOp(op, KintoWallet(payable(_account)).entryPoint(), _chainID, _privateKeyOwners);
//         return op;
//     }
// }

contract SponsorPaymasterExploitTest is SharedSetup {
    using MessageHashUtils for bytes32;
    using SignatureChecker for address;

    function testExploit() public {
        UserOperation[] memory userOps = new UserOperation[](1);
        userOps[0] = _createUserOperation(
            address(_kintoWallet),
            address(counter),
            _kintoWallet.getNonce(),
            privateKeys,
            abi.encodeWithSignature("increment()"),
            address(_paymaster)
        );
        userOps[0].callGasLimit = 40000; // generate from call simulation
        userOps[0].verificationGasLimit = 150000; // verification gas. will add create2 cost (3200+200*length) if initCode exists
        userOps[0].preVerificationGas = 99e18; // should also cover calldata cost.
        userOps[0].maxFeePerGas = 1; // grab from current gas
        userOps[0].maxPriorityFeePerGas = 1e9; // grab from current gas
        userOps[0].signature = _signUserOp(
            userOps[0], KintoWallet(payable(address(_kintoWallet))).entryPoint(), block.chainid, privateKeys
        );

        uint256 balanceBefore = _owner.balance;
        console.log("HACKER BALANCE BEFORE", balanceBefore);

        vm.expectRevert();
        _entryPoint.handleOps(userOps, payable(_owner));

        uint256 balanceAfter = _owner.balance;
        uint256 dust = 100_000;
        assertGt(balanceBefore, balanceAfter - dust, "Hacker's profit is too HIGH");
    }
}
