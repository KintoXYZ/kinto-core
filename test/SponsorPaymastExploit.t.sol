// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import '../src/wallet/KintoWallet.sol';
import '../src/wallet/KintoWalletFactory.sol';
import '../src/paymasters/SponsorPaymaster.sol';
import '../src/KintoID.sol';
import {UserOp} from './helpers/UserOp.sol';
import {UUPSProxy} from './helpers/UUPSProxy.sol';
import {KYCSignature} from './helpers/KYCSignature.sol';

import '@aa/interfaces/IAccount.sol';
import '@aa/interfaces/INonceManager.sol';
import '@aa/interfaces/IEntryPoint.sol';
import '@aa/core/EntryPoint.sol';
import '@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol';
import { UpgradeableBeacon } from '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol';
import {SignatureChecker} from '@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol';
import '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';
import '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol';

import 'forge-std/Test.sol';
import 'forge-std/console.sol';

contract MyOpCreator is UserOp, KYCSignature {
    function _createOp(
      uint _chainID,
      address _account,
      uint nonce,
      uint256[] calldata _privateKeyOwners,
      address _targetContract,
      uint value,
      bytes calldata _bytesOp,
      address _paymaster
    ) public view returns (UserOperation memory op) {
      op = UserOperation({
        sender: _account,
        nonce: nonce,
        initCode: bytes(''),
        callData: abi.encodeCall(KintoWallet.execute, (_targetContract, value, _bytesOp)),
        callGasLimit: 40000, // generate from call simulation
        verificationGasLimit: 150000, // verification gas. will add create2 cost (3200+200*length) if initCode exists
        preVerificationGas: 99e18, // should also cover calldata cost.
        maxFeePerGas: 1, // grab from current gas
        maxPriorityFeePerGas: 1e9, // grab from current gas
        paymasterAndData: abi.encodePacked(_paymaster),
        signature: bytes('')
      });
      op.signature = _signUserOp(op, KintoWallet(payable(_account)).entryPoint(), _chainID, _privateKeyOwners);
      return op;
    }
}

contract Counter {

    uint256 public count;

    constructor() {
      count = 0;
    }

    function increment() public {
        count += 1;
    }
}

contract SponsorPaymasterExploitTest is MyOpCreator {
    using ECDSAUpgradeable for bytes32;
    using SignatureChecker for address;

    EntryPoint _entryPoint;
    KintoWalletFactory _walletFactoryI;
    KintoWalletFactory _walletFactory;
    KintoID _implementation;
    KintoID _kintoIDv1;
    SponsorPaymaster _paymaster;

    KintoWallet _kintoWalletImpl;
    IKintoWallet _kintoWalletv1;
    UUPSProxy _proxy;
    UUPSProxy _proxyf;
    UUPSProxy _proxys;
    UpgradeableBeacon _beacon;

    uint256 _chainID = 1;

    address payable _owner = payable(vm.addr(1));
    address _secondowner = address(2);
    address _user = vm.addr(3);
    address _user2 = address(4);
    address _upgrader = address(5);
    address _kycProvider = address(6);
    address _recoverer = address(7);


    function setUp() public {
        vm.chainId(_chainID);
        vm.startPrank(address(1));
        _owner.transfer(1e18);
        vm.stopPrank();
        vm.startPrank(_owner);
        // Deploy Kinto ID
        _implementation = new KintoID();
        // deploy _proxy contract and point it to _implementation
        _proxy = new UUPSProxy{salt: 0}(address(_implementation), '');
        // wrap in ABI to support easier calls
        _kintoIDv1 = KintoID(address(_proxy));
        // Initialize _proxy
        _kintoIDv1.initialize();
        _kintoIDv1.grantRole(_kintoIDv1.KYC_PROVIDER_ROLE(), _kycProvider);
        _entryPoint = new EntryPoint{salt: 0}();
        // Deploy wallet implementation
        _kintoWalletImpl = new KintoWallet{salt: 0}(_entryPoint, _kintoIDv1);
        //Deploy wallet factory implementation
        _walletFactoryI = new KintoWalletFactory{salt: 0}(_kintoWalletImpl);
        _proxyf = new UUPSProxy{salt: 0}(address(_walletFactoryI), '');
        _walletFactory = KintoWalletFactory(address(_proxyf));
        // Initialize wallet factory
        _walletFactory.initialize(_kintoIDv1);
        // Set the wallet factory in the entry point
        _entryPoint.setWalletFactory(address(_walletFactory));
        // Mint an nft to the owner
        IKintoID.SignatureData memory sigdata = _auxCreateSignature(
            _kintoIDv1, _owner, _owner, 1, block.timestamp + 1000);
        uint8[] memory traits = new uint8[](0);
        vm.startPrank(_kycProvider);
        _kintoIDv1.mintIndividualKyc(sigdata, traits);
        vm.stopPrank();
        vm.startPrank(_owner);
        // deploy walletv1 through wallet factory and initializes it
        _kintoWalletv1 = _walletFactory.createAccount(_owner, _recoverer, 0);
        console.log('wallet address ', address(_kintoWalletv1));
        // deploy the paymaster
        _paymaster = new SponsorPaymaster{salt: 0}(_entryPoint);
        // deploy _proxy contract and point it to _implementation
        _proxys = new UUPSProxy(address(_paymaster), '');
        // wrap in ABI to support easier calls
        _paymaster = SponsorPaymaster(address(_proxys));
        // Initialize proxy
        _paymaster.initialize(_owner);
        vm.stopPrank();
    }

    function testExploit() public {
        vm.startPrank(_owner);
        // Let's deploy the counter contract
        Counter counter = new Counter();
        assertEq(counter.count(), 0);
        vm.stopPrank();
        _setPaymasterForContract(address(counter));
        vm.startPrank(_owner);
        // Let's send a transaction to the counter contract through our wallet
        uint startingNonce = _kintoWalletv1.getNonce();
        uint256[] memory privateKeys = new uint256[](1);
        privateKeys[0] = 1;

        UserOperation memory userOp = this._createOp(
            _chainID,
            address(_kintoWalletv1), 
            startingNonce, 
            privateKeys, 
            address(counter), 
            0,
            abi.encodeWithSignature('increment()'), 
            address(_paymaster)
        );
        UserOperation[] memory userOps = new UserOperation[](1);
        userOps[0] = userOp;
        // Execute the transaction via the entry point
        uint balanceBefore = _owner.balance;
        console.log("HACKER BALANCE BEFORE" , balanceBefore);
        vm.expectRevert();
        _entryPoint.handleOps(userOps, payable(_owner));
        uint balanceAfter = _owner.balance;
        uint dust = 100_000;
        assertGt(
            balanceBefore,
            balanceAfter - dust,
            "Hacker's profit is too HIGH"
        );

        vm.stopPrank();
    }

    function _setPaymasterForContract(address _contract) private {
        vm.startPrank(_owner);
        vm.deal(_owner, 1000e18);
        // We add the deposit to the counter contract in the paymaster
        _paymaster.addDepositFor{value: 100e18}(address(_contract));
        vm.stopPrank();
    }

}
